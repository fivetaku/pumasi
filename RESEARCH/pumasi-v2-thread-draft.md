# 품앗이 V2 스레드 초안

---

## 1/

Claude Code가 Codex를 "외주 개발자"로 부리는 플러그인, 품앗이를 업그레이드했습니다.

이번엔 이론이 아니라 실험(DOE)을 돌리고, 직접 코드를 비교하고, 3번 반복 개선했습니다.

결론부터: Codex한테 어떻게 시키느냐에 따라 코드 품질이 완전히 달라집니다.

---

## 2/

**뭘 했나 — DOE (실험 설계) 8개**

Codex CLI의 실제 동작을 몰랐습니다. 문서만 보고 짐작하면 삽질할 거라 판단하고, 실험부터 설계했습니다.

- E01: instruction 포맷 (최소/상세/구조화 중 뭐가 좋은지)
- E03: 작업 디렉토리 (-C) 경계를 지키는지
- E04: 출력 캡처 (stdout vs -o vs --json)
- E05: 병렬 실행 시 인증 충돌 있는지
- E06: 에러 코드 매핑, 빈 프롬프트 동작
- E07: "추가 파일 생성 금지" 지시가 실제로 작동하는지
- E08: --output-schema로 구조화 JSON 응답 강제
- E10: 컨텍스트 과다 주입 시 품질 저하 여부

각 실험마다 2~5개 변형을 만들어서 비교했습니다.

---

## 3/

**DOE에서 배운 핵심**

1. Codex는 "뭘 만들라"는 지시만으로 "어떻게"를 잘 추론함
2. 하지만 코드 스타일은 비결정적 — 같은 지시로 두 번 돌리면 엣지케이스 처리가 달라짐
3. --output-schema가 작동하려면 모든 properties가 required에 들어가야 함 (OpenAI API 변경)
4. 병렬 5개까지 인증 충돌 없음
5. CLI 부팅 + API 오버헤드 최소 ~6초

이 결과를 바탕으로 품앗이 코드에 반영했습니다.

---

## 4/

**실전 테스트 — 동일 태스크를 Claude와 Codex 양쪽으로 구현**

테스트 셋:
- 공유 타입 파일 1개 (types.ts)
- Round 1: 3개 유틸 모듈 (string-utils, validation-utils, math-utils)
- Round 2: barrel re-export 1개

3가지 instruction 스타일로 동시에 비교:
- Minimal: "함수 3개 만들어" (이름만)
- Structured: 시그니처 + 구현 세부사항 + 금지사항
- Conversational: 대화체 한국어

---

## 5/

**첫 비교 결과: Claude vs Codex (개선 전)**

| | Claude | Codex |
|---|---|---|
| 코드량 | 72줄 | 131줄 (+82%) |
| 품질 | 9.3/10 | 8.8/10 |
| 속도 | 19초 (직렬) | 17초 (병렬) |
| 게이트 | N/A | 20/20 |

Codex가 장황했습니다.
- clamp을 1줄이면 되는 걸 14줄 if/else로
- TypeScript 파라미터에 typeof 방어코드 3개
- 정규식을 모듈 상단에 상수로 분리
- 중간변수 `const isValid = pattern.test(x); if (!isValid)`

---

## 6/

**1차 개선: "간결함 우선" 스타일 규칙 7개 추가**

워커 프롬프트에 코드 스타일 섹션을 추가했습니다:
- 관용적 one-liner 우선 사용
- TypeScript 타입 신뢰, typeof 금지
- 삼항연산자 활용
- 불필요한 중간변수 금지
- 정규식 인라인
- 객체 리터럴 인라인 반환

결과: 131줄 → **57줄 (-56%)**

"와 대박" 하고 좋아했는데...

---

## 7/

**기능 테스트를 돌려보니 기능이 깨져 있었습니다.**

| 함수 | 개선 전 | "간결함 우선" 적용 후 |
|---|---|---|
| truncate(text, 3) | "Hel" ✅ | "..." ❌ |
| truncate(text, 0) | "" ✅ | "..." ❌ |
| formatDate (3월) | "03/05" ✅ | "3/05" ❌ |

간결하게 줄이다가 엣지케이스 분기를 통째로 날려먹은 겁니다.

truncate를 삼항연산자 원라이너로 바꿨더니 maxLength <= 3일 때 분기가 사라졌고,
formatDate를 `toLocaleDateString()`으로 간소화했더니 zero-padding이 날아갔습니다.

교훈: **간결함은 목표가 아니라 수단이다. 기능이 먼저.**

---

## 8/

**2차 개선: "정확성 최우선 + 간결하게"**

프롬프트를 다시 고쳤습니다:

```
- 정확성 최우선: 간결하게 작성하되 모든 엣지케이스의 동작이
  반드시 올바라야 한다. 간결화로 인해 엣지케이스 처리가 달라지면
  간결화를 포기하고 정확한 코드를 작성한다.

- 엣지케이스 명시 규칙:
  - 문자열 절삭: maxLength가 말줄임표(...)보다 짧으면
    말줄임표 없이 원본을 잘라 반환
  - 날짜 포맷: 명시된 포맷 옵션이 있으면 Intl.DateTimeFormat에
    전달 (toLocaleDateString 기본값에 의존하지 않는다)
  - 범위 역전(min > max): 내부에서 swap하여 정상 처리
```

---

## 9/

**최종 결과 (5회 반복 후)**

| | v1 (원본) | v2 (간결 우선) | **v5 (최종)** | Claude |
|---|---|---|---|---|
| 코드량 | 131줄 | 57줄 | **73줄** | 72줄 |
| truncate 엣지 | 부분 통과 | ❌ 3개 깨짐 | **8/8 전부 ✅** | 6/8 |
| clamp 역전 | ❌ 원본반환 | ✅ swap | **✅ swap** | ⚠️ 암묵적 |
| formatDate | ✅ | ❌ padding 소실 | **✅** | ✅ |
| typeof 제거 | ❌ 있음 | ✅ 제거 | **✅ 제거** | ✅ |

v5는 Claude와 동일한 코드량(73줄)이면서, truncate 엣지케이스(음수, 0, <=3)와 clamp 범위 역전 처리가 Claude보다 더 정확합니다.

---

## 10/

**5번의 반복이 증명한 것**

1. Codex의 코드 품질은 모델의 한계가 아니라 **프롬프트의 문제**
2. "간결하게 써" → 기능 깨짐. "정확하게 + 간결하게" → 둘 다 잡음
3. 추상적 원칙("간결함 우선")은 위험. **구체적 코드 예시**(`if (safe <= 3) return text.slice(0, safe)`)를 넣어야 작동
4. 기능 테스트 없이 "줄 수 줄었으니 개선"이라고 하면 안 됨
5. 프롬프트 → 생성 → 기능 테스트 → 프롬프트 수정 **반복 루프**가 핵심

---

## 11/

**품앗이에 실제로 뭐가 바뀌었나**

워커 프롬프트 템플릿에 추가된 것:
- 코드 스타일 규칙 (정확성 최우선 + 관용적 패턴 + 불필요한 방어코드 제거)
- 엣지케이스 명시 규칙 (truncate, 날짜, 범위 역전)
- config에서 `style` 필드로 프로젝트별 커스텀 스타일 주입 가능

그 외 버그 수정:
- output-schema required 필드 (OpenAI API 변경 대응)
- 워커 startedAt 타이밍 데이터 누락
- 라운드 기반 실행, 재위임(autofix) 구현

---

## 12/

**결론**

AI에게 코드를 시키는 건 사람에게 시키는 것과 같습니다.

"대충 해줘" → 대충 나옴
"이렇게 해줘" → 이렇게 나옴
"이렇게 하되, 이건 절대 틀리면 안 돼" → 제대로 나옴

품앗이는 Claude가 이 "이렇게 하되"를 Codex에게 전달하는 시스템입니다.
프롬프트 품질 = 코드 품질. DOE로 증명했습니다.

품앗이 플러그인: https://github.com/gptakuofficial/pumasi

---
